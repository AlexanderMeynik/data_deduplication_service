[На страницу с документацией](README.md)

# Дополнительные детали реализации


## Особенности представления данных
Из-за того, что изначально разработка решения не была под qt6. Основной
функционал для работы с файлами был реализован в ранее упомянутых классах FilesService
и DatabaseService и дополнительных функциях к ним. По этой причине возвращаемые
значения (pqxx::result) изначально были не совместимы с системой отображения Qt. Для
разрешения данной проблемы было принято решение применить подход model/view.

В рамках данного проекта необходимо было отобразить pqxx::result на таблицу,
отфильтровать записи в данной таблице по полю с путём, а также для некторых виджетов
удалить все записи, где есть NULL значения.

Для решения данной задачи пришлось применить подход [Model/View](https://doc.qt.io/qt-6/model-view-programming.html).
Суть данного подхода состоит в том, что архитектура разделяется на классы,
которые отвечают за то, как храниться данные(model) и на классы, которые эти данные
отображаю(view). Использование данной архитектуры позволяет разработчику более
гибко взаимодействовать и отображать данные.

<p align="center">
<img alt="modelview.png" src="images%2Fmodelview.png" title="The model/view architecture"/>
</p>

Полученную иерархию классов можно наблюдать ниже:
<p align="center">
<img alt="modelClasses.png" src="images%2FmodelClasses.png" width="350" 
     height="auto">
</p>

Опишем имеющиеся классы:
1. Класс MyPqxxModelbase реализует основные методы для запроса данных, а также
   для их преобразования от встроенных PostgreSQL типов к тем, которые может
   распознавать QT.
2. Класс MyPqxxModel уже наследует методы табличной модели, что позволяет
   использовать его дял отображения табличных данных. Данный класс позволяет
   получать данные по любому (выбранному разработчиком) запросу.
3. Класс DeduplicationCharacteristicsModel может запрашивать только данные только
   по 1 запросу.
4. Класс MySortFilterProxyModel позволяет отфильтровывать элементы модели по 1
   колонке.
5. Класс NotNullFilterProxyModel удаляет все ряды, где присутствуют пустые
   QVariant().
   Более подробно документацию классов-моделей для моей реализации проекта можно найти
   на [сайте](https://alexandermeynik.github.io/data_deduplication_service/namespacemodels.html).

## Особенности реализации процедуры хеширования
Рассмотрим следующий фрагмент кода:
```c++
constexpr std::array<unsigned char *(*)(const unsigned char *d, size_t n, unsigned char *md), 5> funcs
 = {&SHA224, &SHA256,
 &MD5, &SHA384, &SHA512};
/**
* Enum for selected hash function
*/
enum hash_function {
 SHA_224,
 SHA_256,
 MD_5,
 SHA_384,
 SHA_512
};
/**
* Generates hash string with specified hash function
* @tparam hash
* @param stringView
*/
template<hash_function hash = MD_5>
std::string getHashStr(std::string_view stringView);
/**
* Lookup table for hash function size
*/
static constexpr std::array<unsigned short, 5> hash_function_size
 {
 SHA224_DIGEST_LENGTH,
 SHA256_DIGEST_LENGTH,
 MD5_DIGEST_LENGTH,
 SHA384_DIGEST_LENGTH,
 SHA512_DIGEST_LENGTH
 };
/**
* Lookup table for hash function name
*/
static constexpr std::array<const char *, 5> hash_function_name
 {
 "sha224",
 "sha256",
 "md5",
 "sha384",
 "sha512"
 };
```

Как можно видеть для определения функции, ей названия, размера хэш строки и
используются lookup таблицы. Таким образом процедура добавления новой функции будет
заключаться в добавлении новой записи для новой хэш функции в funcs, hash_function,
hash_function_name, hash_function_size. Подобная реализация позволяет разработчику
быстро вносить новые варианты для хэширования без создания лишних ветвлений, а также
багов т.к. данная реализация предоставляет единый интерфейс для работы с хеш-функциями.

### Особенности организации процесса разработки

Ввиду растущего размера проекта. А также необходимости собирать код
приложения. Выполнять набор простых тестов для проверки его функциональности и
собирать другие артефакты, которые будут полезны в ходе разработки. Целесообразным
решением будет оптимизировать данные процессы для увеличения частоты изменений и их
безопасности.

Для оптимизации вышеописанных процессов было принято решение использовать
реализовывать [CI/CD](https://github.com/resources/articles/devops/ci-cd) процессы на базе GitHub actions:
Для упаковки всех необходимых зависимостей и фиксации конфигурации сборки
был создан fat docker образ окружения для сборки всего проекта. Найти его можно в [docker
hub](https://hub.docker.com/repository/docker/alexandermey/data-deduplication-service/general) репозитории данного проекта и его применение интегрировано в workflow GitHub
actions.

Созданный набор workflow можно использовать и запускать в различных условиях.
Список workflow [репозитория](https://github.com/AlexanderMeynik/data_deduplication_service) на момент написания отчёта можно найти в левой части
фотографии:

<p align="center">
<img alt="benchWorkdlowspng.png" src="images%2FbenchWorkdlowspng.png"  width="400" 
     height="auto">
</p>

## Описание работы основных методов системы

Несмотря на то, что в общем случае диаграмма из рис.2 как правило верна в общем
случае после завершения процедур по загрузке файла, она не отражает некоторые
временные сущности, которые возникают в ходе выполнения данных процедур (в
частности, при загрузке файла).
<p align="center">
<img alt="database2.svg" src="images%2Fdatabase2.svg" width="600" 
     height="auto">
</p>
Новые сущности на данной диаграмме:

1. Временная таблица файла (TempFileTable) – данная таблица создаётся при создании
   новой записи для файла и служит временным буфером для всех его данных. Для
   данной таблице не создаётся ограничений и индексов для увеличения скорости
   вставки в неё. Данная таблица удаляется в конце обработки файла
   (finishFileProcessing).
2. Агрегированная таблица файла (AggregationTable) – данная таблица создаётся из
   содержимого первой таблицы для учёта числа уникальных сегментов для
   выбранного файла. Данная таблица создаётся после вставки всех данных файла во
   временную таблицу и удаляется после завершения работы с сегментами.

Примерное содержимое TempFileTable для файла 32blocks.txt и размера блока 64 байта:
<p align="center">
<img alt="tempTable.png" height="auto" src="images%2FtempTable.png"
width="400"/>
</p>

Примерное содержимое AggregationTable для файла 32blocks.txt и размера блока 64 байта:
<p align="center">
<img alt="AggregationTable.png" height="auto" src="images%2FAggregationTable.png"
width="400"/>
</p>


### Загрузка файла в систему
Диаграмма последовательности для применяемой процедуры может быть найдена
ниже:
<p align="center">
<img alt="processFile.svg" height="auto" src="images%2FprocessFile.svg"
width="600"/>
</p>

Процедуру по загрузке файла можно разделить следующие этапы:
1. Создание записи в таблице с файлами под новое вхождение;
2. Пакетная вставка данных файла во временную таблицу;
3. Обработка изменений сегментов;
4. Вставка данных файла;

При создании записи для файла происходит создание временной таблицы
для хранения данных этого файла. Название временной таблицы будет формироваться по следующему принципу:
1. hash = md5(filename)=c239801dee73cc4916e1f81da90db210
2. tableName = temp_table_||hash

Временная таблица не содержит индексов и ключей, что позволяет быстро вставлять
содержимое файла без проведения стандартных проверок на вышеупомянутые
ограничения.

Использование insert запросов при пакетной вставке содержимого файла не всегда
является целесообразным решением. Для его применения необходимо иметь все данные
файла, загруженные в оперативную память, или самостоятельно реализовывать блочную
передачу, что тоже не совсем корректно.

При выполнении данной операции необходимо
добиться возможности отправки сегментов файла по мере их считывания (считал очередной
сегмент сразу отправил его в формате пакета). В рамках библиотеки pqxx подобной
функциональности можно добиться при помощи [pqxx::stream_to](https://libpqxx.readthedocs.io/stable/streams.html). Данные объекты имеются
«потоковыми запросами» и позволяют добиться большей производительности при
считывании и записи файлов. Помимо этого, было принято решение вычислять хэш
значения блоков на стороне клиента, что можно выполнить, используя соответствующие
[функции](https://docs.openssl.org/1.1.1/man3/SHA256_Init/#synopsis) OpenSSL.

Для работы с сегментами из данных временной таблицы создаётся агрегированная по хэшу сегмента таблицы с вычисленным числом сегментов.
Название для данной таблице формируется по схожей процедуре с упомянутой ранее временной таблице.
При работе с данной таблице основная задача сводиться к объединению её данных с основной таблицей сегментов.
Для этого используется upsert запрос ([on conflict](https://www.postgresql.org/docs/current/sql-insert.html)), чтобы обновлять счётчики сегментов там в тех случаях, когда эти сегменты уже есть в БД, и добавлять новые записи в ином случае.
Для ускорения проверки на хэш блока в данной таблице был создан индекс.
После завершения данной операции агрегированная таблица удаляется.

Самый последний этап производит вставку данных из временной таблицы в таблицу с данными(data).
После чего временная таблица также удаляется.

### Выгрузка файла

Диаграмма последовательности для применяемой процедуры может быть найден
ниже:

<p align="center">
<img alt="loadFile.svg" height="auto" src="images%2FloadFile.svg"
width="600"/>
</p>

Выгрузка файла состоит из 1 этапа. Для его выполнения производиться inner join
таблиц c данными и сегментами. Упомянутый ранее механизм «потоковых запросов»
применяется и здесь для последовательного считывания значении сегментов.

### Удаление файла
Диаграмма последовательности для применяемой процедуры может быть найден
ниже:
<p align="center">
<img alt="deleteFile.svg" height="auto" src="images%2FdeleteFile.svg"
width="600"/>
</p>

Для полного удаления информации о файле необходимо выполнить следующие
шаги:

1. Уменьшить счётчики блоков, которые были использованы в файле.
2. Удалить данные файла из таблицы data.
3. Удалить запись о файле из таблицы с файлами.
4. Удалить блоки с нулевыми счётчиками

Наличие индекса на значении хэша в таблице с сегментами позволяет эффективнее
взаимодействовать с данной таблицей при изменении данных. В то время как индекс на id
файла позволяет эффективно отфильтровывать только нужные сегменты из таблицы data.

### Обзор возможностей GUI
Главная страница приложения приведена ниже. Для удобства восприятия важные
секции были отмечены красными цифрами.

<p align="center">
<img alt="ui.svg" height="auto" src="images%2Fui.svg"
width="450"/>
</p>
Рассмотрим основные секции данного интерфейса:

1. Первая секция является основным меню приложения и содержит кнопку для
   открытия настроек.
2. Вторая секция позволяет пользователю выбирать БД для подключения. Также
   пользователь может удалить существующую БД и создать новую.
3. Третья секция содержит набор виджетов для загрузки файлов/директорий в базу
   данных. Пользователь может выбрать размер сегмента, хэш функцию, а также тип
   (файл или директория) загружаемого объекта.
4. Четвёртая секция содержит информацию о выбранном ниже файле. В данной секции
   присутствуют поля с процентом уникальности сегментов и коэффициентом
   дедупликации (*100). Помимо этого, в данной секции пользователь может выбрать
   опцию Replace Files, что приведёт, к тому, что при загрузке данных все
   существующие файлы будут перезаписываться.
5. Пятая секция представляет из себя таблицу с основной информацией по
   загруженным файлам. При выборе 1 из элементов часть данных будет отображаться
   в 4 секции.
6. Шестая секция позволяет пользователю удалять существующие файлы/директории
   или выгружать их. При вводе пути пользователю будет предложен список
   возможных вариантов для выбора. Выгружать можно только записи 1 типа: если мы
   выгружаем директорию, то выходной путь должен быть директорией, аналогично и
   в случае файла.
   <p align="center">
   <img alt="dataSelector.png" src="images%2FdataSelector.png"
   width="250"/>
   </p>
7. седьмой секции выводиться основана информация о времени удаления/выгрузки
   данных, а также число ошибок при сравнении. В данной секции содержится набор
   опций для выгрузки:
    - Delete entry – при выборе удаляет запись со всеми данными после выгрузки
    - Create root directory – если для выходного пути не существует родительской
      директории, она будет создана.
    - Compare output – после выгрузки сравнивает файлы до дедупликации и после
      выгрузки, если оба экземпляра сохранились.
8. Последняя секция представляет из себя простое текстовое поля для просмотра логов.

Страница настроек позволяет пользователю выбрать файл для конфигурации или
создать таковой с выбранными значениями полей. Также существует возможность
проверить является ли текущая строка подключения рабочей:
<p align="center">
<img alt="ui2.svg" height="auto" src="images%2Fui2.svg"
width="450"/>
</p>


[На страницу с документацией](README.md)
